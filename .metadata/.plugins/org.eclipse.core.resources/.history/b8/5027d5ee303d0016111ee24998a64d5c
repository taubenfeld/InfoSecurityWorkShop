#include "stateful.h"

connections_list_entry connections_list;
int logs_size = 0;

/*
 * Variables that uses for the read operation.
 */
char *read_buffer;
int remaining_number_of_bytes_to_read;
char *pointer_to_current_location_in_read_buffer;

/***************************************************************************************************
 * List handling methods.
 **************************************************************************************************/

void add_log(unsigned long timestamp, unsigned char protocol, unsigned char action,
    unsigned char hooknum, __be32 src_ip, __be32 dst_ip, __be16 src_port, __be16 dst_port,
    reason_t reason) {
  connections_list_entry *cur_entry;
  connections_list_entry *new;

  struct timeval time;
  do_gettimeofday(&time);

  // Check if this log already exists.
  list_for_each_entry(cur_entry, &(connections_list.list), list) {
    if (cur_entry->protocol == protocol
        && cur_entry->action == action
        && cur_entry->hooknum == hooknum
        && cur_entry->src_ip == src_ip
        && cur_entry->dst_ip == dst_ip
        && cur_entry->src_port == src_port
        && cur_entry->dst_port == dst_port
        && cur_entry->reason == reason) {
      // We found an equal log, increment its count field and update its timestamp.
      cur_entry->count++;
      cur_entry->timestamp = time.tv_sec;
      return;
    }
  }

  // The log doesn't exists in the list. Create a new node.
  // Note that it is important to use GFP_ATOMIC due to concurrency considerations.
  new = kmalloc(sizeof(connections_list_entry), GFP_ATOMIC);
  if (new == NULL) {
    printk(KERN_INFO "ERROR: Failed to allocate space for new log. Not adding the current log.\n");
    return;
  }

  INIT_LIST_HEAD(&(new->list));
  new->timestamp = time.tv_sec;
  new->protocol = protocol;
  new->action = action;
  new->hooknum = hooknum;
  new->src_ip = src_ip;
  new->dst_ip = dst_ip;
  new->src_port = src_port;
  new->dst_port = dst_port;
  new->reason = reason;
  new->count = 1;
  list_add_tail(&(new->list), &connections_list.list);
  logs_size++;
}

void clear_connections_list(void) {
  connections_list_entry *cur_entry, *temp;
  if (list_empty(&(connections_list.list))) { // List is empty nothing to do.
    return;
  }
  list_for_each_entry_safe(cur_entry, temp, &(connections_list.list), list) {
    list_del(&(cur_entry->list));
    kfree(cur_entry);
  }
  logs_size = 0;
}

void get_logs(char *buff) {
  connections_list_entry *cur_entry;
  char temp_str_log[LOG_SIZE_AS_STRING + 1] = {0};

  // Start to read from where we stopped last time (cur_entry_in_read).
  // Use this to align printing. Currently the align parsing is done only in userspace.
  // "%-19.lu %-19.u %-19.u %-19.u %-19.u %-19.u %-19.u %-19.u %-19.d %-19.u\n",
  list_for_each_entry(cur_entry, &(connections_list.list), list) {
    scnprintf(temp_str_log, LOG_SIZE_AS_STRING + 1,
        "%lu %u %u %u %u %u %u %u %d %u\n",
        cur_entry->timestamp,
        cur_entry->protocol,
        cur_entry->action,
        cur_entry->hooknum,
        cur_entry->src_ip,
        cur_entry->dst_ip,
        cur_entry->src_port,
        cur_entry->dst_port,
        cur_entry->reason,
        cur_entry->count);
    strcat(buff, temp_str_log);
  }
}
int get_logs_size(void) {
  return logs_size;
}

void init_connections_list(void) {
  INIT_LIST_HEAD(&connections_list.list);
  logs_size = 0;
}
