#include "stateful.h"

int logs_device_major_number;
struct device* logs_device_sysfs_device = NULL;

connections_list_entry connections_list;
int list_size = 0;

/*
 * Variables that uses for the read operation.
 */
char *read_buffer;
int remaining_number_of_bytes_to_read;
char *pointer_to_current_location_in_read_buffer;
/***************************************************************************************************
 * Private methods.
 **************************************************************************************************/


/**
 * Adding a new connection with the given arguments. It is assumed that the caller already checked
 * that this is a valid connection.
 */
void add_connection(
    __be32 src_ip, __be16 src_port, __be32 dst_ip, __be16 dst_port, __u16 fragment) {
  connections_list_entry *new;
  struct timeval time;
  do_gettimeofday(&time);

  // Note that it is important to use GFP_ATOMIC due to concurrency considerations.
  new = kmalloc(sizeof(connections_list_entry), GFP_ATOMIC);
  if (new == NULL) {
    printk(KERN_INFO "ERROR: Failed to allocate space for new log. Not adding the current log.\n");
    return;
  }

  INIT_LIST_HEAD(&(new->list));
  new->timestamp = time.tv_sec;
  new->src_ip = src_ip;
  new->dst_ip = dst_ip;
  new->src_port = src_port;
  new->dst_port = dst_port;
  new->fragment = fragment;
  new->tcp_state = SENT_SYN_WAIT_SYNACK;

  // TODO: Specify protocol.
  list_add_tail(&(new->list), &connections_list.list);
  list_size++;
}

void remove_connection(connections_list_entry *entry) {
  if (list_empty(&(connections_list.list))) { // List is empty nothing to do.
    return;
  }
  list_del(&(entry->list));
  kfree(entry);
  list_size--;
}
connections_list_entry *find_connection(
    __be32 src_ip, __be16 src_port, __be32 dst_ip, __be16 dst_port) {
  connections_list_entry *cur_entry;
  list_for_each_entry(cur_entry, &(connections_list.list), list) {
//    printk(KERN_INFO "cur_entry->src_ip = [%u], cur_entry->src_port = [%u], cur_entry->dst_ip = [%u], cur_entry->dst_port = [%u].",
//        cur_entry->src_ip, cur_entry->src_port, cur_entry->dst_ip, cur_entry->dst_port);
//    printk(KERN_INFO "src_ip = [%u], src_port = [%u], dst_ip = [%u], dst_port = [%u].",
//        src_ip, src_port, dst_ip, dst_port);
    if ((cur_entry->src_ip == src_ip && cur_entry->src_port == src_port
        && cur_entry->dst_ip == dst_ip && cur_entry->dst_port == dst_port) ||
        (cur_entry->src_ip == dst_ip && cur_entry->src_port == dst_port
        && cur_entry->dst_ip == src_ip && cur_entry->dst_port == src_port)) {
      return cur_entry;
    }
  }
  printk(KERN_INFO "Didn't find anything.");
  return NULL;
}

void get_connections_as_string(char *buff, int size) {
  log_row_t *cur_entry;
  char temp_str_log[ROW_SIZE_AS_STRING + 1] = {0};
  int cursize = 0;

  list_for_each_entry(cur_entry, &(logs_list.list), list) {
    cursize += scnprintf(temp_str_log, LOG_SIZE_AS_STRING + 1,
        "%%u %u %u %u %u\n",
        cur_entry->src_ip,
        cur_entry->src_port,
        cur_entry->dst_ip,
        cur_entry->dst_port,
        cur_entry->protocol);
    if (cursize >= size) {
      return; // Maximum capacity.
    }
    strcat(buff, temp_str_log);
  }
}

void clear_connections_list(void) {
  connections_list_entry *cur_entry, *temp;
  if (list_empty(&(connections_list.list))) { // List is empty nothing to do.
    return;
  }
  list_for_each_entry_safe(cur_entry, temp, &(connections_list.list), list) {
    list_del(&(cur_entry->list));
    kfree(cur_entry);
  }
  list_size = 0;
}

int get_list_size(void) {
  return list_size;
}

void init_connections_list(void) {
  INIT_LIST_HEAD(&connections_list.list);
  list_size = 0;
}


/***************************************************************************************************
 * Public methods.
 **************************************************************************************************/


int validate_and_update_connection(__be32 src_ip, __be16 src_port, __be32 dst_ip, __be16 dst_port,
    __u16 fragment, int syn, int ack, int fin, reason_t *reason) {
  connections_list_entry *connection = find_connection(src_ip, src_port, dst_ip, dst_port);
  // Convert syn and ack to a more comfortable form.
  syn = syn == ACK_YES ? 1 : 0;
  ack = ack == ACK_YES ? 1 : 0;
  fin = fin == ACK_YES ? 1 : 0;
  if (connection == NULL) {
    if (syn && !ack) {
      printk(KERN_INFO "Creating connection.");
      add_connection(src_ip, src_port, dst_ip , dst_port, fragment);
      *reason = VALID_TCP_CONNECTION;
      return NF_ACCEPT;
    } else {
      printk(KERN_INFO "Connection not exists.");
      *reason = CONN_NOT_EXIST;
      return NF_DROP;
    }
  }
  switch (connection->tcp_state) {
    case SENT_SYN_WAIT_SYNACK:
      printk(KERN_INFO "in SENT_SYN_WAIT_SYNACK.");
      if (ack && syn) {
        printk(KERN_INFO "Received syn ack.");
        connection->tcp_state = SENT_SYNACK_WAIT_ACK;
        *reason = VALID_TCP_CONNECTION;
        return NF_ACCEPT;
      }
      break;
    case SENT_SYNACK_WAIT_ACK:
      if (ack && !syn) {
        printk(KERN_INFO "Received ack.");
        connection->tcp_state = ESTABLISHED;
        *reason = VALID_TCP_CONNECTION;
        return NF_ACCEPT;
      }
      break;
    case ESTABLISHED:
      if (!ack && !syn) {
        if (fin) {
          printk(KERN_INFO "Received fin removing connection.");
          // TODO: handle fin.
          remove_connection(connection);
          *reason = VALID_TCP_CONNECTION;
          return NF_ACCEPT;
        }
        printk(KERN_INFO "Received normal packet afther connection established.");
        // TODO: Handle protocol state.
        *reason = VALID_TCP_CONNECTION;
        return NF_ACCEPT;
      }
      break;
  }
  printk(KERN_INFO "Not a valid packet.");
  *reason = TCP_NON_COMPLIANT;
  return NF_DROP;
}


/***************************************************************************************************
 * Driver file operations.
 **************************************************************************************************/

/*
 * Our custom open function for file_operations. Each time we open the device we initializing the
 * changing variables (so we will be able to read it again and again).
 *
 * In this implementation we prepare the buffer that should be sent to the user.
 */
int open_log_device(struct inode *_inode, struct file *_file) {

  remaining_number_of_bytes_to_read =
      (list_size + 1) * ROW_SIZE_AS_STRING + 1;

  // Prepare all the logs that should be written.
  read_buffer = kcalloc(remaining_number_of_bytes_to_read, 1, GFP_KERNEL);
  if (read_buffer == NULL) {
    return -1;
  }
  pointer_to_current_location_in_read_buffer = read_buffer;

  // Fill the buffer with the logs.
  get_connections_as_string(read_buffer, remaining_number_of_bytes_to_read);

  return 0;
}

/*
 * Implementation for the read method of file_operations.
 */
ssize_t read_logs(struct file *filp, char *buff, size_t length, loff_t *offp) {
  ssize_t bytes_to_write_in_the_current_iteration =
      (remaining_number_of_bytes_to_read < length) ? remaining_number_of_bytes_to_read : length;

  // If nothing left to write return.
  if (bytes_to_write_in_the_current_iteration == 0) {
    return 0;
  }

  // Send the data to the user through 'copy_to_user'
  if (copy_to_user(
      buff, pointer_to_current_location_in_read_buffer, bytes_to_write_in_the_current_iteration)) {
    kfree(read_buffer);
    return -EFAULT;
  } else {
    // function succeeded, we just sent the user 'num_of_bytes' bytes, so we updating the counter
    // and the string pointer index.
    remaining_number_of_bytes_to_read -= bytes_to_write_in_the_current_iteration;
    pointer_to_current_location_in_read_buffer += bytes_to_write_in_the_current_iteration;
    return bytes_to_write_in_the_current_iteration;
  }
}

int release_log_device(struct inode *inode, struct file *file) {
  kfree(read_buffer);
  return 0;
}

/*
 * File operations for log device.
 */
static struct file_operations logs_device_fops = {
  .owner = THIS_MODULE,
  .open = open_log_device,
  .read = read_logs,
  .release = release_log_device
};


/***************************************************************************************************
 * Driver sysfs ops.
 **************************************************************************************************/

/*
 * Sysfs show logs size implementation.
 */
ssize_t sysfs_show_logs_size(struct device *dev,struct device_attribute *attr, char *buf) {
  return scnprintf(buf, sizeof(int) + 1 , "%d\n", get_logs_size());
}
/*
 * Register attribute for display size.
 */
static DEVICE_ATTR(log_size, S_IROTH, sysfs_show_logs_size, NULL);


/*
 * Sysfs clear logs implementation.
 */
ssize_t sysfs_clear_logs(
    struct device *dev, struct device_attribute *attr, const char *buf, size_t count) {
  char c;
  int returnValue;
  if((returnValue = sscanf(buf, "%c", &c)) == 1) {
    clear_logs_list();
  }
  printk(KERN_INFO "Done clearing log\n");
  return returnValue;
}

/*
 * Register ops.
 */
static DEVICE_ATTR(log_clear, S_IWOTH , NULL, sysfs_clear_logs);


/***************************************************************************************************
 * Registration methods.
 **************************************************************************************************/


